#!/bin/bash

# üè¥‚Äç‚ò†Ô∏è Skull King - Script de gestion unifi√©
# Usage: sk [command]

# Auto-d√©tection du r√©pertoire du projet
# Si le script est dans /usr/local/bin, on utilise le r√©pertoire courant
# Sinon, on utilise le r√©pertoire du script

if [[ "$(realpath "$0")" == "/usr/local/bin/sk" ]]; then
    # Script install√© globalement, utiliser le r√©pertoire courant
    PROJECT_DIR="$(pwd)"
    # V√©rifier si on est dans un projet Skull King valide
    if [[ ! -d "backend" ]] || [[ ! -d "frontend" ]]; then
        # Essayer de trouver le projet dans les r√©pertoires parents
        current_dir="$(pwd)"
        found=false
        while [[ "$current_dir" != "/" ]]; do
            if [[ -d "$current_dir/backend" ]] && [[ -d "$current_dir/frontend" ]] && [[ -f "$current_dir/sk" ]]; then
                PROJECT_DIR="$current_dir"
                found=true
                break
            fi
            current_dir="$(dirname "$current_dir")"
        done
        
        if [[ "$found" != true ]]; then
            PROJECT_DIR="/home/sydnec/skullking_js"  # Fallback
        fi
    fi
else
    # Script local, utiliser le r√©pertoire du script
    PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

BACKEND_DIR="$PROJECT_DIR/backend"
FRONTEND_DIR="$PROJECT_DIR/frontend"
LOG_DIR="$BACKEND_DIR/logs"
BACKUP_DIR="$PROJECT_DIR/backups"

# Validation du r√©pertoire de projet
validate_project_directory() {
    if [[ ! -d "$BACKEND_DIR" ]] || [[ ! -d "$FRONTEND_DIR" ]]; then
        print_error "Ce r√©pertoire ne semble pas √™tre un projet Skull King valide."
        print_error "R√©pertoires attendus :"
        print_error "  - Backend: $BACKEND_DIR"
        print_error "  - Frontend: $FRONTEND_DIR"
        print_error ""
        print_error "R√©pertoire actuel d√©tect√© : $PROJECT_DIR"
        print_error "Assurez-vous d'√™tre dans le r√©pertoire racine du projet ou que les r√©pertoires existent."
        exit 1
    fi
}

# Cr√©ation du r√©pertoire de backup si n√©cessaire
ensure_backup_dir() {
    if [[ ! -d "$BACKUP_DIR" ]]; then
        mkdir -p "$BACKUP_DIR"
    fi
}

# Fonction pour trouver le chemin de la base de donn√©es
find_database_path() {
    local db_paths=(
        "$BACKEND_DIR/prisma/prisma/dev.db"
        "$BACKEND_DIR/prisma/dev.db"
        "$BACKEND_DIR/dev.db"
    )
    
    for path in "${db_paths[@]}"; do
        if [[ -f "$path" ]]; then
            echo "$path"
            return 0
        fi
    done
    
    # Retourner le chemin standard si aucun fichier trouv√©
    echo "$BACKEND_DIR/prisma/prisma/dev.db"
    return 1
}

# Fonction de sauvegarde de la base de donn√©es
backup_database() {
    ensure_backup_dir
    local backup_file="$BACKUP_DIR/db_backup_$(date +%Y%m%d_%H%M%S).db"
    local db_path
    
    db_path=$(find_database_path)
    
    if [[ -f "$db_path" ]]; then
        cp "$db_path" "$backup_file"
        print_success "Base de donn√©es sauvegard√©e : $backup_file"
        print_success "Source: $db_path"
        return 0
    else
        print_warning "Aucune base de donn√©es trouv√©e"
        print_warning "Emplacements v√©rifi√©s:"
        print_warning "  - $BACKEND_DIR/prisma/prisma/dev.db"
        print_warning "  - $BACKEND_DIR/prisma/dev.db"
        print_warning "  - $BACKEND_DIR/dev.db"
        return 1
    fi
}

# Fonction de restauration de la base de donn√©es
restore_database() {
    local backup_file="$1"
    
    if [[ -z "$backup_file" ]]; then
        print_error "Fichier de sauvegarde requis"
        echo "Usage: sk restore <fichier_backup>"
        echo "Sauvegardes disponibles:"
        ls -la "$BACKUP_DIR"/*.db 2>/dev/null || echo "Aucune sauvegarde trouv√©e"
        return 1
    fi
    
    if [[ ! -f "$backup_file" ]]; then
        print_error "Fichier de sauvegarde non trouv√©: $backup_file"
        return 1
    fi
    
    local db_path
    db_path=$(find_database_path)
    
    # Cr√©er le r√©pertoire si n√©cessaire
    mkdir -p "$(dirname "$db_path")"
    
    print_step "Arr√™t du backend pour la restauration..."
    pm2 stop skullking-backend 2>/dev/null || echo "Backend d√©j√† arr√™t√©"
    
    print_step "Restauration de la base de donn√©es..."
    cp "$backup_file" "$db_path"
    print_success "Base de donn√©es restaur√©e vers: $db_path"
    
    print_step "Red√©marrage du backend..."
    pm2 start "$BACKEND_DIR/ecosystem.config.cjs" --env production
    
    if check_app_status; then
        print_success "Base de donn√©es restaur√©e avec succ√®s"
    else
        print_error "Erreur lors de la restauration"
    fi
}

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

print_section() {
    echo -e "${CYAN}üìä $1${NC}"
    echo "----------------------------"
}

print_step() {
    echo -e "${GREEN}[√âTAPE]${NC} $1"
}

print_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

print_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

# Fonction pour v√©rifier si l'application est en ligne
check_app_status() {
    if pm2 list 2>/dev/null | grep -q "skullking-backend.*online"; then
        return 0
    else
        return 1
    fi
}

# Fonction de monitoring compl√®te
monitor_function() {
    clear
    echo -e "${PURPLE}üè¥‚Äç‚ò†Ô∏è SKULL KING - MONITORING${NC}"
    echo "================================="
    echo ""
    
    # 1. Statut PM2
    print_section "Statut PM2"
    if pm2 list 2>/dev/null | grep -q "skullking-backend"; then
        pm2 list
        echo ""
        if check_app_status; then
            print_success "Backend Skull King en ligne"
        else
            print_error "Backend Skull King hors ligne"
        fi
    else
        print_error "Aucun processus PM2 trouv√©"
    fi
    echo ""

    # 2. Test de l'API
    print_section "Test de l'API"
    if curl -s http://localhost:3001/health >/dev/null 2>&1; then
        print_success "API accessible"
        echo "R√©ponse: $(curl -s http://localhost:3001/health)"
    else
        print_error "API non accessible"
    fi
    echo ""

    # 3. Ressources syst√®me
    print_section "Ressources syst√®me"
    echo "üíæ M√©moire: $(free -h | awk '/^Mem:/ {printf "Utilis√©e: %s/%s (%.2f%%)", $3, $2, ($3/$2)*100}')"
    echo "üî• CPU: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//')% utilis√©"
    echo "üíø Disque: $(df -h / | awk 'NR==2 {printf "Utilis√©: %s/%s (%s)", $3, $2, $5}')"
    echo ""

    # 4. Connectivit√© r√©seau
    print_section "Connectivit√© r√©seau"
    echo "üåê IP locale: $(hostname -I | awk '{print $1}' 2>/dev/null || ipconfig getifaddr en0 2>/dev/null || echo "Non disponible")"
    if ss -tuln 2>/dev/null | grep -q ":3001 " || netstat -an 2>/dev/null | grep -q ":3001.*LISTEN"; then
        print_success "Port 3001 (Backend) ouvert et en √©coute"
    else
        print_error "Port 3001 (Backend) non accessible"
    fi
    echo ""

    # 5. Logs r√©cents
    print_section "Logs r√©cents (derni√®res 5 lignes)"
    pm2 logs skullking-backend --lines 5 --nostream 2>/dev/null || echo "Aucun log disponible"
    echo ""

    # 6. Informations de d√©ploiement
    print_section "Informations de d√©ploiement"
    if [ -f "$FRONTEND_DIR/.next/BUILD_ID" ]; then
        echo "üìÖ Derni√®re mise √† jour du build frontend: $(stat -c %y "$FRONTEND_DIR/.next/BUILD_ID" 2>/dev/null || stat -f %Sm "$FRONTEND_DIR/.next/BUILD_ID" 2>/dev/null || echo "Non disponible")"
    fi
    echo "üìÅ R√©pertoire projet: $PROJECT_DIR"
    echo "üìÅ Backend: $BACKEND_DIR"
    echo "üìÅ Frontend: $FRONTEND_DIR"
    echo "üë§ Utilisateur: $(whoami)"
    echo "üñ•Ô∏è  Hostname: $(hostname)"
    echo ""
    echo "üîÑ Pour actualiser: sk monitor"
    echo "üìä Pour PM2 monitoring: pm2 monit"
    echo "üìã Pour red√©marrer: sk restart"
}

# Fonction de mise √† jour
update_function() {
    cd "$PROJECT_DIR" || {
        print_error "Impossible d'acc√©der au r√©pertoire $PROJECT_DIR"
        exit 1
    }

    print_step "üîÑ Mise √† jour Skull King..."
    
    # Sauvegarde des logs
    print_step "Sauvegarde des logs actuels..."
    if [ -f "$LOG_DIR/combined.log" ]; then
        cp "$LOG_DIR/combined.log" "$LOG_DIR/combined.log.backup.$(date +%Y%m%d_%H%M%S)"
    fi

    # V√©rifier et arr√™ter PM2 si n√©cessaire
    print_step "üìã V√©rification du statut PM2..."
    if pm2 describe skullking-backend &> /dev/null; then
        print_step "‚úÖ Processus PM2 'skullking-backend' trouv√©"
        print_step "Arr√™t temporaire de l'application..."
        pm2 stop skullking-backend
    else
        print_warning "‚ö†Ô∏è Processus PM2 'skullking-backend' non trouv√©"
    fi

    # Sauvegarde de la base de donn√©es
    print_step "Sauvegarde de la base de donn√©es..."
    local db_path
    db_path=$(find_database_path)
    if [[ -f "$db_path" ]]; then
        cp "$db_path" "${db_path}.backup.$(date +%Y%m%d_%H%M%S)"
        print_success "Base de donn√©es sauvegard√©e"
    fi

    # Git pull
    print_step "R√©cup√©ration des derni√®res modifications..."
    git pull origin main || print_warning "Impossible de faire git pull"

    # Installation des d√©pendances backend
    print_step "Installation des d√©pendances backend..."
    cd "$BACKEND_DIR"
    npm i

    # Retour au backend pour Prisma
    cd "$BACKEND_DIR"

    # G√©n√©ration Prisma
    print_step "G√©n√©ration du client Prisma..."
    npx prisma generate

    # Migration de la base de donn√©es
    print_step "Migration de la base de donn√©es..."
    NODE_ENV=production npx prisma db push

    # Red√©marrage
    print_step "Red√©marrage de l'application..."
    pm2 restart skullking-backend || pm2 start ecosystem.config.cjs --env production
    pm2 save

    # V√©rification finale
    sleep 5
    if check_app_status; then
        print_success "üéâ Mise √† jour termin√©e avec succ√®s!"
        print_success "Le backend est en ligne sur http://localhost:3001"
        print_success "Le frontend peut √™tre d√©ploy√© s√©par√©ment"
    else
        print_error "‚ùå Probl√®me lors de la mise √† jour"
        echo "V√©rifiez les logs avec: sk logs"
    fi
}

# Fonction d'installation du script dans le PATH
install_script() {
    local script_path="/usr/local/bin/sk"
    
    if [[ -f "$script_path" ]]; then
        echo -n "Le script est d√©j√† install√©. Voulez-vous le mettre √† jour? (O/n): "
        read -n 1 confirmation
        echo ""
        if [[ ! "$confirmation" =~ ^[Oo]$ ]] && [[ -n "$confirmation" ]]; then
            print_warning "Installation annul√©e"
            return 1
        fi
    fi
    
    print_step "Installation du script sk dans /usr/local/bin..."
    
    # Copier le script
    if sudo cp "$PROJECT_DIR/sk" "$script_path"; then
        sudo chmod +x "$script_path"
        print_success "Script install√© avec succ√®s!"
        print_success "Vous pouvez maintenant utiliser 'sk' depuis n'importe o√π"
        echo ""
        echo "üí° Conseils:"
        echo "  - Utilisez 'sk' depuis le r√©pertoire du projet ou ses sous-r√©pertoires"
        echo "  - Le script d√©tectera automatiquement le bon r√©pertoire de projet"
        echo "  - Pour d√©sinstaller: sudo rm /usr/local/bin/sk"
    else
        print_error "Erreur lors de l'installation (permissions sudo requises)"
        return 1
    fi
}

# Fonction pour incr√©menter la version et taguer automatiquement
release_auto() {
    local type="patch"
    local version_regex='^v([0-9]+)\.([0-9]+)\.([0-9]+)$'
    if [[ "$2" == "major" || "$2" == "minor" || "$2" == "patch" ]]; then
        type="$2"
    fi

    print_section "Release automatique ($type)"
    print_step "Passage sur main et pull..."
    git checkout main || { print_error "Impossible de passer sur main"; return 1; }
    git pull origin main || { print_error "Impossible de pull main"; return 1; }

    # R√©cup√©rer le dernier tag
    last_tag=$(git tag --sort=-v:refname | grep -E "$version_regex" | head -n1)
    if [[ -z "$last_tag" ]]; then
        last_tag="v0.0.0"
    fi
    if [[ $last_tag =~ $version_regex ]]; then
        major=${BASH_REMATCH[1]}
        minor=${BASH_REMATCH[2]}
        patch=${BASH_REMATCH[3]}
    else
        major=0; minor=0; patch=0
    fi

    case "$type" in
        major)
            major=$((major+1)); minor=0; patch=0;;
        minor)
            minor=$((minor+1)); patch=0;;
        patch|*)
            patch=$((patch+1));;
    esac
    new_tag="v${major}.${minor}.${patch}"

    # Mettre √† jour la version dans package.json (racine)
    if [ -f "$PROJECT_DIR/package.json" ]; then
        jq ".version = \"${major}.${minor}.${patch}\"" "$PROJECT_DIR/package.json" > "$PROJECT_DIR/package.json.tmp" && mv "$PROJECT_DIR/package.json.tmp" "$PROJECT_DIR/package.json"
        print_success "Version mise √† jour dans package.json (racine)"
    fi
    # Mettre √† jour la version dans backend/package.json
    if [ -f "$PROJECT_DIR/backend/package.json" ]; then
        jq ".version = \"${major}.${minor}.${patch}\"" "$PROJECT_DIR/backend/package.json" > "$PROJECT_DIR/backend/package.json.tmp" && mv "$PROJECT_DIR/backend/package.json.tmp" "$PROJECT_DIR/backend/package.json"
        print_success "Version mise √† jour dans backend/package.json"
    fi
    # Mettre √† jour la version dans frontend/package.json
    if [ -f "$PROJECT_DIR/frontend/package.json" ]; then
        jq ".version = \"${major}.${minor}.${patch}\"" "$PROJECT_DIR/frontend/package.json" > "$PROJECT_DIR/frontend/package.json.tmp" && mv "$PROJECT_DIR/frontend/package.json.tmp" "$PROJECT_DIR/frontend/package.json"
        print_success "Version mise √† jour dans frontend/package.json"
    fi
    git add package.json backend/package.json frontend/package.json 2>/dev/null
    git commit -m "v${major}.${minor}.${patch}" || echo "Aucun changement √† committer"
    git push origin main || { print_error "Impossible de push sur main"; return 1; }

    print_step "Nouveau tag: $new_tag"
    git tag "$new_tag" || { print_error "Impossible de cr√©er le tag"; return 1; }
    git push origin "$new_tag" || { print_error "Impossible de push le tag"; return 1; }
    print_success "Release $new_tag pouss√©e sur main !"
}

case "$1" in
    dev)
        validate_project_directory
        echo "üöÄ Lancement du mode d√©veloppement..."
        echo "Backend sur http://localhost:3001"
        echo "Frontend sur http://localhost:3000"
        echo ""
        print_step "D√©marrage du backend..."
        cd "$BACKEND_DIR"
        npm run dev &
        BACKEND_PID=$!
        
        print_step "D√©marrage du frontend..."
        cd "$FRONTEND_DIR"
        npm run dev &
        FRONTEND_PID=$!
        
        echo ""
        print_success "D√©veloppement d√©marr√©!"
        echo "Appuyez sur Ctrl+C pour arr√™ter les deux serveurs"
        
        # Attendre l'interruption et tuer les processus
        trap 'echo ""; print_step "Arr√™t des serveurs..."; kill $BACKEND_PID $FRONTEND_PID 2>/dev/null; print_success "Serveurs arr√™t√©s"; exit 0' INT
        wait
        ;;
    build)
        validate_project_directory
        print_section "Construction du Frontend"
        cd "$FRONTEND_DIR"
        print_step "Installation des d√©pendances..."
        npm i
        echo ""
        print_step "Build en cours..."
        npm run build
        echo ""
        if [ $? -eq 0 ]; then
            print_success "üéâ Frontend build√© avec succ√®s!"
            echo ""
            echo "üìä Informations de build:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "üìÅ R√©pertoire: $FRONTEND_DIR"
            echo "üì¶ Build situ√© dans: .next/"
            echo "üöÄ Pr√™t pour le d√©ploiement"
            echo ""
            echo "üí° Prochaines √©tapes:"
            echo "  ‚Ä¢ D√©ployer sur Vercel ou autre plateforme"
            echo "  ‚Ä¢ Ou utiliser: sk deploy-full (pour d√©ploiement local)"
        else
            print_error "‚ùå Erreur lors du build"
            echo ""
            echo "üîç V√©rifications sugg√©r√©es:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "  ‚Ä¢ V√©rifiez les erreurs ci-dessus"
            echo "  ‚Ä¢ Assurez-vous que toutes les d√©pendances sont install√©es"
            echo "  ‚Ä¢ V√©rifiez la configuration TypeScript/Next.js"
        fi
        ;;
    start)
        validate_project_directory
        print_section "D√©marrage du Backend Skull King"
        cd "$BACKEND_DIR"
        pm2 start ecosystem.config.cjs --env production 2>/dev/null || {
            print_warning "Processus d√©j√† en cours, tentative de red√©marrage..."
            pm2 restart skullking-backend
        }
        pm2 save
        sleep 2
        echo ""
        if check_app_status; then
            print_success "üéâ Backend Skull King d√©marr√© avec succ√®s!"
            echo ""
            echo "üìä Informations de connexion:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "üåê Backend: http://localhost:3001"
            echo "üè• Health: http://localhost:3001/health"
            echo ""
            echo "üí° Commandes utiles:"
            echo "  ‚Ä¢ sk status    - V√©rifier l'√©tat"
            echo "  ‚Ä¢ sk logs      - Voir les logs"
            echo "  ‚Ä¢ sk monitor   - Monitoring complet"
        else
            print_error "‚ùå √âchec du d√©marrage"
            echo ""
            echo "üîç V√©rifications sugg√©r√©es:"
            echo "  ‚Ä¢ V√©rifiez les logs: sk logs"
            echo "  ‚Ä¢ V√©rifiez les permissions"
            echo "  ‚Ä¢ Red√©marrez: sk restart"
        fi
        ;;
    stop)
        print_section "Arr√™t du Backend Skull King"
        pm2 stop skullking-backend 2>/dev/null || print_warning "Application d√©j√† arr√™t√©e"
        echo ""
        print_success "üõë Backend Skull King arr√™t√© avec succ√®s"
        echo ""
        echo "üí° Pour red√©marrer:"
        echo "  ‚Ä¢ sk start     - D√©marrer le backend"
        echo "  ‚Ä¢ sk restart   - Red√©marrer directement"
        ;;
    restart)
        print_section "Red√©marrage du Backend Skull King"
        cd "$BACKEND_DIR"
        pm2 restart skullking-backend 2>/dev/null || {
            print_warning "Processus non trouv√©, d√©marrage..."
            pm2 start ecosystem.config.cjs --env production
        }
        pm2 save
        sleep 2
        echo ""
        if check_app_status; then
            print_success "üîÑ Backend Skull King red√©marr√© avec succ√®s!"
            echo ""
            echo "üìä Informations de connexion:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "üåê Backend: http://localhost:3001"
            echo "üè• Health: http://localhost:3001/health"
            echo ""
            echo "üí° Commandes utiles:"
            echo "  ‚Ä¢ sk api       - Tester l'API"
            echo "  ‚Ä¢ sk logs      - Voir les logs"
            echo "  ‚Ä¢ sk monitor   - Monitoring complet"
        else
            print_error "‚ùå √âchec du red√©marrage"
            echo ""
            echo "üîç V√©rifications sugg√©r√©es:"
            echo "  ‚Ä¢ V√©rifiez les logs: sk logs"
            echo "  ‚Ä¢ Essayez un arr√™t/d√©marrage: sk stop && sk start"
        fi
        ;;
    status)
        print_section "Statut du Backend Skull King"
        if check_app_status; then
            print_success "üü¢ Backend Skull King en ligne"
            echo ""
            echo "üìä Informations rapides:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "üåê Endpoint: http://localhost:3001"
            echo "‚ö° Processus PM2: Actif"
            echo ""
            echo "üí° Commandes utiles:"
            echo "  ‚Ä¢ sk api       - Test complet de l'API"
            echo "  ‚Ä¢ sk logs      - Voir les logs en temps r√©el"
            echo "  ‚Ä¢ sk monitor   - Monitoring d√©taill√©"
        else
            print_error "üî¥ Backend Skull King hors ligne"
            echo ""
            echo "üîç Actions sugg√©r√©es:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "  ‚Ä¢ sk start     - D√©marrer le backend"
            echo "  ‚Ä¢ sk logs      - V√©rifier les erreurs"
            echo "  ‚Ä¢ sk deploy    - Red√©ployer si n√©cessaire"
        fi
        ;;
    logs)
        print_section "Logs du Backend Skull King"
        echo "üìã Affichage en temps r√©el (Ctrl+C pour arr√™ter)"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo ""
        pm2 logs skullking-backend 2>/dev/null || {
            print_error "Impossible d'acc√©der aux logs"
            echo ""
            echo "üîç V√©rifications:"
            echo "  ‚Ä¢ Le backend est-il d√©marr√©? sk status"
            echo "  ‚Ä¢ Essayez de red√©marrer: sk restart"
        }
        ;;
    monitor)
        monitor_function
        ;;
    update)
        update_function
        ;;
    deploy)
        echo "üöÄ D√©ploiement backend..."
        cd "$PROJECT_DIR"
        
        # Sauvegarde automatique avant d√©ploiement
        print_step "Sauvegarde automatique avant d√©ploiement..."
        backup_database || echo "Continuer sans sauvegarde..."
        
        # V√©rification et cr√©ation du fichier .env backend
        print_step "V√©rification de la configuration d'environnement backend..."
        cd "$BACKEND_DIR"
        if [ ! -f ".env" ]; then
            if [ -f ".env.example" ]; then
                print_step "Copie de .env.example vers .env..."
                cp .env.example .env
                print_success "Fichier .env cr√©√© √† partir de .env.example"
            else
                print_warning "Ni .env ni .env.example trouv√©s dans le backend"
            fi
        else
            print_success "Fichier .env d√©j√† pr√©sent dans le backend"
        fi
        
        # Arr√™t de l'application
        print_step "Arr√™t de l'application si elle est en cours d'ex√©cution..."
        pm2 stop skullking-backend 2>/dev/null || echo "Backend pas encore d√©marr√©"

        # Installation des d√©pendances backend
        print_step "Installation des d√©pendances backend..."
        cd "$BACKEND_DIR"
        npm i

        # G√©n√©ration du client Prisma
        print_step "G√©n√©ration du client Prisma..."
        npx prisma generate

        # Initialisation de la base de donn√©es
        print_step "Initialisation de la base de donn√©es de production..."
        NODE_ENV=production npx prisma db push

        # D√©marrage du backend avec PM2
        print_step "D√©marrage du backend avec PM2..."
        cd "$BACKEND_DIR"
        pm2 start ecosystem.config.cjs --env production

        # Sauvegarde de la configuration PM2
        print_step "Sauvegarde de la configuration PM2..."
        pm2 save

        # V√©rification finale
        sleep 5
        if check_app_status; then
            print_success "üéâ D√©ploiement backend termin√© avec succ√®s!"
            print_success "Backend accessible sur http://localhost:3001"
            print_success "Le frontend peut √™tre d√©ploy√© s√©par√©ment"
        else
            print_error "‚ùå Probl√®me lors du d√©ploiement"
        fi
        ;;
    deploy-full)
        echo "üöÄ D√©ploiement complet (backend + frontend)..."
        cd "$PROJECT_DIR"
        
        # V√©rification et cr√©ation du fichier .env backend
        print_step "V√©rification de la configuration d'environnement backend..."
        cd "$BACKEND_DIR"
        if [ ! -f ".env" ]; then
            if [ -f ".env.example" ]; then
                print_step "Copie de .env.example vers .env..."
                cp .env.example .env
                print_success "Fichier .env cr√©√© √† partir de .env.example"
            else
                print_warning "Ni .env ni .env.example trouv√©s dans le backend"
            fi
        else
            print_success "Fichier .env d√©j√† pr√©sent dans le backend"
        fi
        
        # V√©rification et cr√©ation du fichier .env frontend
        print_step "V√©rification de la configuration d'environnement frontend..."
        cd "$FRONTEND_DIR"
        if [ ! -f ".env.local" ]; then
            if [ -f ".env.example" ]; then
                print_step "Copie de .env.example vers .env.local..."
                cp .env.example .env.local
                print_success "Fichier .env.local cr√©√© √† partir de .env.example"
            else
                print_warning "Ni .env.local ni .env.example trouv√©s dans le frontend"
            fi
        else
            print_success "Fichier .env.local d√©j√† pr√©sent dans le frontend"
        fi
        
        # Arr√™t de l'application
        print_step "Arr√™t de l'application si elle est en cours d'ex√©cution..."
        pm2 stop skullking-backend 2>/dev/null || echo "Backend pas encore d√©marr√©"

        # Installation des d√©pendances backend
        print_step "Installation des d√©pendances backend..."
        cd "$BACKEND_DIR"
        npm i

        # G√©n√©ration du client Prisma
        print_step "G√©n√©ration du client Prisma..."
        npx prisma generate

        # Initialisation de la base de donn√©es
        print_step "Initialisation de la base de donn√©es de production..."
        NODE_ENV=production npx prisma db push

        # Installation des d√©pendances frontend
        print_step "Installation des d√©pendances frontend..."
        cd "$FRONTEND_DIR"
        npm i

        # Build du frontend
        print_step "Construction du frontend..."
        npm run build

        # D√©marrage du backend avec PM2
        print_step "D√©marrage du backend avec PM2..."
        cd "$BACKEND_DIR"
        pm2 start ecosystem.config.cjs --env production

        # Sauvegarde de la configuration PM2
        print_step "Sauvegarde de la configuration PM2..."
        pm2 save

        # V√©rification finale
        sleep 5
        if check_app_status; then
            print_success "üéâ D√©ploiement complet termin√© avec succ√®s!"
            print_success "Backend accessible sur http://localhost:3001"
            print_success "Frontend build√© et pr√™t √† √™tre d√©ploy√©"
        else
            print_error "‚ùå Probl√®me lors du d√©ploiement"
        fi
        ;;
    api)
        print_section "V√©rification de la sant√© de l'API"
        if curl -s http://localhost:3001/health >/dev/null 2>&1; then
            response=$(curl -s http://localhost:3001/health)
            print_success "API accessible et fonctionnelle"
            echo ""
            
            # Parser et afficher les informations de mani√®re jolie
            if command -v jq >/dev/null 2>&1; then
                # Si jq est disponible, parser le JSON proprement
                echo "üìä D√©tails de sant√©:"
                echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                echo "üü¢ Statut: $(echo "$response" | jq -r '.status // "N/A"')"
                echo "‚è∞ Timestamp: $(echo "$response" | jq -r '.timestamp // "N/A"')"
                echo "‚è±Ô∏è  Uptime: $(echo "$response" | jq -r '.uptime // "N/A"')"
                echo "üíæ M√©moire utilis√©e: $(echo "$response" | jq -r '.memory.used // "N/A"')"
                echo "üíæ M√©moire totale: $(echo "$response" | jq -r '.memory.total // "N/A"')"
                echo "üåç Environnement: $(echo "$response" | jq -r '.environment // "N/A"')"
                echo "üîí SSL: $(echo "$response" | jq -r '.ssl // "N/A"')"
            else
                # Si jq n'est pas disponible, affichage simple mais joli
                echo "üìä R√©ponse de l'API:"
                echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                echo "$response" | sed 's/,/\n/g' | sed 's/[{}"]//g' | sed 's/:/: /g' | while read line; do
                    if [[ -n "$line" ]]; then
                        echo "  $line"
                    fi
                done
            fi
            echo ""
            print_success "üéâ L'API Skull King est en parfaite sant√©!"
            echo "üåê Endpoint: http://localhost:3001/health"
        else
            print_error "API non accessible"
            echo ""
            echo "üîç V√©rifications √† effectuer:"
            echo "  1. Le backend est-il d√©marr√©? (sk status)"
            echo "  2. Le port 3001 est-il libre?"
            echo "  3. Y a-t-il des erreurs dans les logs? (sk logs)"
        fi
        ;;
    install)
        install_script
        ;;
    backup)
        validate_project_directory
        print_section "Sauvegarde de la Base de Donn√©es"
        if backup_database; then
            echo ""
            echo "üí° Commandes utiles:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "  ‚Ä¢ sk restore <fichier>  - Restaurer une sauvegarde"
            echo "  ‚Ä¢ ls -la $BACKUP_DIR    - Voir toutes les sauvegardes"
        else
            echo ""
            echo "üîç V√©rifications:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "  ‚Ä¢ La base de donn√©es existe-t-elle?"
            echo "  ‚Ä¢ Le backend a-t-il √©t√© initialis√©? sk deploy"
        fi
        ;;
    restore)
        validate_project_directory
        if [[ -n "$2" ]]; then
            print_section "Restauration de la Base de Donn√©es"
            restore_database "$2"
        else
            print_section "Sauvegardes Disponibles"
            if ls "$BACKUP_DIR"/*.db 1> /dev/null 2>&1; then
                echo "üìã Fichiers de sauvegarde trouv√©s:"
                echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                ls -la "$BACKUP_DIR"/*.db
                echo ""
                echo "üìñ Usage:"
                echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                echo "  sk restore <fichier_backup>"
                echo ""
                echo "üìù Exemple:"
                echo "  sk restore $BACKUP_DIR/db_backup_20250821_194101.db"
            else
                print_warning "Aucune sauvegarde trouv√©e dans $BACKUP_DIR"
                echo ""
                echo "üí° Pour cr√©er une sauvegarde:"
                echo "  sk backup"
            fi
        fi
        ;;
    reset)
        # V√©rifier si l'option --y ou -y est pr√©sente
        auto_confirm=false
        if [[ "$2" == "--y" ]] || [[ "$2" == "-y" ]]; then
            auto_confirm=true
        fi
        
        echo "üîÑ R√©initialisation compl√®te du projet..."
        echo ""
        echo -e "${YELLOW}‚ö†Ô∏è  ATTENTION: Cette action va supprimer toutes les donn√©es!${NC}"
        echo -e "${YELLOW}‚ö†Ô∏è  Les utilisateurs, salles de jeu et parties seront perdues!${NC}"
        echo ""
        
        # Sauvegarde de s√©curit√© avant reset
        if [[ "$auto_confirm" != true ]]; then
            echo "üíæ Cr√©ation d'une sauvegarde de s√©curit√© avant reset..."
            backup_database || echo "Continuer sans sauvegarde..."
            echo ""
        fi
        
        if [ "$auto_confirm" = true ]; then
            echo "Mode automatique activ√© (--y), confirmation ignor√©e"
            confirmation="o"
        else
            echo -n "√ätes-vous s√ªr de vouloir continuer? (O/n): "
            read -n 1 confirmation
            echo ""
        fi
        
        if [[ "$confirmation" =~ ^[Oo]$ ]] || [ -z "$confirmation" ]; then
            cd "$PROJECT_DIR" || {
                print_error "Impossible d'acc√©der au r√©pertoire $PROJECT_DIR"
                exit 1
            }

            # Suppression des logs
            print_step "Suppression des logs..."
            if [ -d "$LOG_DIR" ]; then
                rm -rf "$LOG_DIR"
                mkdir -p "$LOG_DIR"
                touch "$LOG_DIR/combined.log"
                touch "$LOG_DIR/error.log"
                touch "$LOG_DIR/out.log"
                print_success "Logs supprim√©s et r√©pertoire recr√©√©"
            else
                print_warning "R√©pertoire de logs non trouv√©, cr√©ation d'un nouveau"
                mkdir -p "$LOG_DIR"
            fi

            # Suppression de la base de donn√©es
            print_step "Suppression de la base de donn√©es..."
            db_path=$(find_database_path)
            if [[ -f "$db_path" ]]; then
                rm -f "$db_path"
                print_success "Base de donn√©es supprim√©e"
            fi

            # Arr√™t et suppression du processus PM2
            print_step "Arr√™t du processus PM2..."
            pm2 stop skullking-backend 2>/dev/null || echo "Processus d√©j√† arr√™t√©"
            pm2 delete skullking-backend 2>/dev/null || echo "Processus non trouv√©"

            # R√©initialisation de la base de donn√©es
            print_step "R√©initialisation de la base de donn√©es..."
            cd "$BACKEND_DIR"
            npx prisma db push --force-reset

            # Red√©marrage
            print_step "Red√©marrage de l'application..."
            pm2 start ecosystem.config.cjs --env production
            pm2 save
            
            sleep 2
            if check_app_status; then
                print_success "Projet r√©initialis√© et pr√™t √† utiliser"
                print_success "Backend accessible sur http://localhost:3001"
            else
                print_error "Erreur lors de la r√©initialisation"
            fi
        else
            print_warning "R√©initialisation annul√©e"
        fi
        ;;
    release)
        # Usage: sk release [patch|minor|major]
        release_auto "$@"
        ;;
    *)
        echo -e "${PURPLE}üè¥‚Äç‚ò†Ô∏è SKULL KING - Script de gestion unifi√©${NC}"
        echo "============================================="
        echo ""
        echo "Usage: sk [commande]"
        echo ""
        echo "Commandes disponibles:"
        echo ""
        echo "üöÄ Gestion de l'application:"
        echo "  start         - D√©marre le backend"
        echo "  stop          - Arr√™te le backend"
        echo "  restart       - Red√©marre le backend"
        echo "  status        - Affiche le statut du backend"
        echo ""
        echo "üìä Monitoring et logs:"
        echo "  logs          - Affiche les logs PM2 du backend en temps r√©el"
        echo "  monitor       - Monitoring complet avec ressources syst√®me"
        echo "  api           - V√©rifie la sant√© de l'API backend"
        echo ""
        echo "üîß D√©veloppement:"
        echo "  dev           - Lance le d√©veloppement (backend + frontend)"
        echo "  build         - Build le frontend uniquement"
        echo ""
        echo "üöÄ D√©ploiement:"
        echo "  deploy        - D√©ploiement backend uniquement (recommand√©)"
        echo "  deploy-full   - D√©ploiement backend + build frontend"
        echo "  update        - Mise √† jour du backend"
        echo ""
        echo "üíæ Sauvegarde et restauration:"
        echo "  backup        - Sauvegarde la base de donn√©es"
        echo "  restore       - Restaure une sauvegarde (sk restore <fichier>)"
        echo ""
        echo "‚öôÔ∏è Configuration:"
        echo "  install       - Installe le script dans le PATH global"
        echo "  reset         - R√©initialise compl√®tement le projet (‚ö†Ô∏è SUPPRIME TOUTES LES DONN√âES)"
        echo "                  Options: --y ou -y pour confirmer automatiquement"
        echo "  release       - Cr√©e une release automatique (patch|minor|major)"
        echo ""
        echo "Architecture:"
        echo "  üìÅ Backend : Port 3001 (API + Socket.IO)"
        echo "  üìÅ Frontend: Port 3000 (Next.js - dev) ou d√©ploy√© s√©par√©ment"
        echo ""
        exit 1
        ;;
esac
