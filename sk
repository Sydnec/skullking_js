#!/bin/bash

# ğŸ´â€â˜ ï¸ Skull King - Script de gestion unifiÃ©
# Usage: sk [command]

# Auto-dÃ©tection du rÃ©pertoire du projet
# Si le script est dans /usr/local/bin, on utilise le rÃ©pertoire courant
# Sinon, on utilise le rÃ©pertoire du script

if [[ "$(realpath "$0")" == "/usr/local/bin/sk" ]]; then
    # Script installÃ© globalement, utiliser le rÃ©pertoire courant
    PROJECT_DIR="$(pwd)"
    # VÃ©rifier si on est dans un projet Skull King valide
    if [[ ! -d "backend" ]] || [[ ! -d "frontend" ]]; then
        # Essayer de trouver le projet dans les rÃ©pertoires parents
        current_dir="$(pwd)"
        found=false
        while [[ "$current_dir" != "/" ]]; do
            if [[ -d "$current_dir/backend" ]] && [[ -d "$current_dir/frontend" ]] && [[ -f "$current_dir/sk" ]]; then
                PROJECT_DIR="$current_dir"
                found=true
                break
            fi
            current_dir="$(dirname "$current_dir")"
        done
        
        if [[ "$found" != true ]]; then
            PROJECT_DIR="/home/sydnec/skullking_js"  # Fallback
        fi
    fi
else
    # Script local, utiliser le rÃ©pertoire du script
    PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

BACKEND_DIR="$PROJECT_DIR/backend"
FRONTEND_DIR="$PROJECT_DIR/frontend"
LOG_DIR="$BACKEND_DIR/logs"
BACKUP_DIR="$PROJECT_DIR/backups"

# Validation du rÃ©pertoire de projet
validate_project_directory() {
    if [[ ! -d "$BACKEND_DIR" ]] || [[ ! -d "$FRONTEND_DIR" ]]; then
        print_error "Ce rÃ©pertoire ne semble pas Ãªtre un projet Skull King valide."
        print_error "RÃ©pertoires attendus :"
        print_error "  - Backend: $BACKEND_DIR"
        print_error "  - Frontend: $FRONTEND_DIR"
        print_error ""
        print_error "RÃ©pertoire actuel dÃ©tectÃ© : $PROJECT_DIR"
        print_error "Assurez-vous d'Ãªtre dans le rÃ©pertoire racine du projet ou que les rÃ©pertoires existent."
        exit 1
    fi
}

# CrÃ©ation du rÃ©pertoire de backup si nÃ©cessaire
ensure_backup_dir() {
    if [[ ! -d "$BACKUP_DIR" ]]; then
        mkdir -p "$BACKUP_DIR"
    fi
}

# Fonction pour trouver le chemin de la base de donnÃ©es
find_database_path() {
    local db_paths=(
        "$BACKEND_DIR/prisma/prisma/dev.db"
        "$BACKEND_DIR/prisma/dev.db"
        "$BACKEND_DIR/dev.db"
    )
    
    for path in "${db_paths[@]}"; do
        if [[ -f "$path" ]]; then
            echo "$path"
            return 0
        fi
    done
    
    # Retourner le chemin standard si aucun fichier trouvÃ©
    echo "$BACKEND_DIR/prisma/prisma/dev.db"
    return 1
}

# Fonction de sauvegarde de la base de donnÃ©es
backup_database() {
    ensure_backup_dir
    local backup_file="$BACKUP_DIR/db_backup_$(date +%Y%m%d_%H%M%S).db"
    local db_path
    
    db_path=$(find_database_path)
    
    if [[ -f "$db_path" ]]; then
        cp "$db_path" "$backup_file"
        print_success "Base de donnÃ©es sauvegardÃ©e : $backup_file"
        print_success "Source: $db_path"
        return 0
    else
        print_warning "Aucune base de donnÃ©es trouvÃ©e"
        print_warning "Emplacements vÃ©rifiÃ©s:"
        print_warning "  - $BACKEND_DIR/prisma/prisma/dev.db"
        print_warning "  - $BACKEND_DIR/prisma/dev.db"
        print_warning "  - $BACKEND_DIR/dev.db"
        return 1
    fi
}

# Fonction de restauration de la base de donnÃ©es
restore_database() {
    local backup_file="$1"
    
    if [[ -z "$backup_file" ]]; then
        print_error "Fichier de sauvegarde requis"
        echo "Usage: sk restore <fichier_backup>"
        echo "Sauvegardes disponibles:"
        ls -la "$BACKUP_DIR"/*.db 2>/dev/null || echo "Aucune sauvegarde trouvÃ©e"
        return 1
    fi
    
    if [[ ! -f "$backup_file" ]]; then
        print_error "Fichier de sauvegarde non trouvÃ©: $backup_file"
        return 1
    fi
    
    local db_path
    db_path=$(find_database_path)
    
    # CrÃ©er le rÃ©pertoire si nÃ©cessaire
    mkdir -p "$(dirname "$db_path")"
    
    print_step "ArrÃªt du backend pour la restauration..."
    pm2 stop skullking-backend 2>/dev/null || echo "Backend dÃ©jÃ  arrÃªtÃ©"
    
    print_step "Restauration de la base de donnÃ©es..."
    cp "$backup_file" "$db_path"
    print_success "Base de donnÃ©es restaurÃ©e vers: $db_path"
    
    print_step "RedÃ©marrage du backend..."
    pm2 start "$BACKEND_DIR/ecosystem.config.cjs" --env production
    
    if check_app_status; then
        print_success "Base de donnÃ©es restaurÃ©e avec succÃ¨s"
    else
        print_error "Erreur lors de la restauration"
    fi
}

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

print_section() {
    echo -e "${CYAN}ğŸ“Š $1${NC}"
    echo "----------------------------"
}

print_step() {
    echo -e "${GREEN}[Ã‰TAPE]${NC} $1"
}

print_success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}âš ï¸  $1${NC}"
}

print_error() {
    echo -e "${RED}âŒ $1${NC}"
}

# Fonction pour vÃ©rifier si l'application est en ligne
check_app_status() {
    if pm2 list 2>/dev/null | grep -q "skullking-backend.*online"; then
        return 0
    else
        return 1
    fi
}

# Fonction de monitoring complÃ¨te
monitor_function() {
    clear
    echo -e "${PURPLE}ğŸ´â€â˜ ï¸ SKULL KING - MONITORING${NC}"
    echo "================================="
    echo ""
    
    # 1. Statut PM2
    print_section "Statut PM2"
    if pm2 list 2>/dev/null | grep -q "skullking-backend"; then
        pm2 list
        echo ""
        if check_app_status; then
            print_success "Backend Skull King en ligne"
        else
            print_error "Backend Skull King hors ligne"
        fi
    else
        print_error "Aucun processus PM2 trouvÃ©"
    fi
    echo ""

    # 2. Test de l'API
    print_section "Test de l'API"
    if curl -s http://localhost:3001/health >/dev/null 2>&1; then
        print_success "API accessible"
        echo "RÃ©ponse: $(curl -s http://localhost:3001/health)"
    else
        print_error "API non accessible"
    fi
    echo ""

    # 3. Ressources systÃ¨me
    print_section "Ressources systÃ¨me"
    echo "ğŸ’¾ MÃ©moire: $(free -h | awk '/^Mem:/ {printf "UtilisÃ©e: %s/%s (%.2f%%)", $3, $2, ($3/$2)*100}')"
    echo "ğŸ”¥ CPU: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//')% utilisÃ©"
    echo "ğŸ’¿ Disque: $(df -h / | awk 'NR==2 {printf "UtilisÃ©: %s/%s (%s)", $3, $2, $5}')"
    echo ""

    # 4. ConnectivitÃ© rÃ©seau
    print_section "ConnectivitÃ© rÃ©seau"
    echo "ğŸŒ IP locale: $(hostname -I | awk '{print $1}' 2>/dev/null || ipconfig getifaddr en0 2>/dev/null || echo "Non disponible")"
    if ss -tuln 2>/dev/null | grep -q ":3001 " || netstat -an 2>/dev/null | grep -q ":3001.*LISTEN"; then
        print_success "Port 3001 (Backend) ouvert et en Ã©coute"
    else
        print_error "Port 3001 (Backend) non accessible"
    fi
    echo ""

    # 5. Logs rÃ©cents
    print_section "Logs rÃ©cents (derniÃ¨res 5 lignes)"
    pm2 logs skullking-backend --lines 5 --nostream 2>/dev/null || echo "Aucun log disponible"
    echo ""

    # 6. Informations de dÃ©ploiement
    print_section "Informations de dÃ©ploiement"
    if [ -f "$FRONTEND_DIR/.next/BUILD_ID" ]; then
        echo "ğŸ“… DerniÃ¨re mise Ã  jour du build frontend: $(stat -c %y "$FRONTEND_DIR/.next/BUILD_ID" 2>/dev/null || stat -f %Sm "$FRONTEND_DIR/.next/BUILD_ID" 2>/dev/null || echo "Non disponible")"
    fi
    echo "ğŸ“ RÃ©pertoire projet: $PROJECT_DIR"
    echo "ğŸ“ Backend: $BACKEND_DIR"
    echo "ğŸ“ Frontend: $FRONTEND_DIR"
    echo "ğŸ‘¤ Utilisateur: $(whoami)"
    echo "ğŸ–¥ï¸  Hostname: $(hostname)"
    echo ""
    echo "ğŸ”„ Pour actualiser: sk monitor"
    echo "ğŸ“Š Pour PM2 monitoring: pm2 monit"
    echo "ğŸ“‹ Pour redÃ©marrer: sk restart"
}

# Fonction de mise Ã  jour
update_function() {
    cd "$PROJECT_DIR" || {
        print_error "Impossible d'accÃ©der au rÃ©pertoire $PROJECT_DIR"
        exit 1
    }

    print_step "ğŸ”„ Mise Ã  jour Skull King..."
    
    # Sauvegarde des logs
    print_step "Sauvegarde des logs actuels..."
    if [ -f "$LOG_DIR/combined.log" ]; then
        cp "$LOG_DIR/combined.log" "$LOG_DIR/combined.log.backup.$(date +%Y%m%d_%H%M%S)"
    fi

    # VÃ©rifier et arrÃªter PM2 si nÃ©cessaire
    print_step "ğŸ“‹ VÃ©rification du statut PM2..."
    if pm2 describe skullking-backend &> /dev/null; then
        print_step "âœ… Processus PM2 'skullking-backend' trouvÃ©"
        print_step "ArrÃªt temporaire de l'application..."
        pm2 stop skullking-backend
    else
        print_warning "âš ï¸ Processus PM2 'skullking-backend' non trouvÃ©"
    fi

    # Sauvegarde de la base de donnÃ©es
    print_step "Sauvegarde de la base de donnÃ©es..."
    local db_path
    db_path=$(find_database_path)
    if [[ -f "$db_path" ]]; then
        cp "$db_path" "${db_path}.backup.$(date +%Y%m%d_%H%M%S)"
        print_success "Base de donnÃ©es sauvegardÃ©e"
    fi

    # Git pull
    print_step "RÃ©cupÃ©ration des derniÃ¨res modifications..."
    git pull origin main || print_warning "Impossible de faire git pull"

    # Installation des dÃ©pendances backend
    print_step "Installation des dÃ©pendances backend..."
    cd "$BACKEND_DIR"
    npm i

    # Retour au backend pour Prisma
    cd "$BACKEND_DIR"

    # GÃ©nÃ©ration Prisma
    print_step "GÃ©nÃ©ration du client Prisma..."
    npx prisma generate

    # Migration de la base de donnÃ©es
    print_step "Migration de la base de donnÃ©es..."
    NODE_ENV=production npx prisma db push

    # RedÃ©marrage
    print_step "RedÃ©marrage de l'application..."
    pm2 restart skullking-backend || pm2 start ecosystem.config.cjs --env production
    pm2 save

    # VÃ©rification finale
    sleep 5
    if check_app_status; then
        print_success "ğŸ‰ Mise Ã  jour terminÃ©e avec succÃ¨s!"
        print_success "Le backend est en ligne sur http://localhost:3001"
        print_success "Le frontend peut Ãªtre dÃ©ployÃ© sÃ©parÃ©ment"
    else
        print_error "âŒ ProblÃ¨me lors de la mise Ã  jour"
        echo "VÃ©rifiez les logs avec: sk logs"
    fi
}

# Fonction d'installation du script dans le PATH
install_script() {
    local script_path="/usr/local/bin/sk"
    
    if [[ -f "$script_path" ]]; then
        echo -n "Le script est dÃ©jÃ  installÃ©. Voulez-vous le mettre Ã  jour? (O/n): "
        read -n 1 confirmation
        echo ""
        if [[ ! "$confirmation" =~ ^[Oo]$ ]] && [[ -n "$confirmation" ]]; then
            print_warning "Installation annulÃ©e"
            return 1
        fi
    fi
    
    print_step "Installation du script sk dans /usr/local/bin..."
    
    # Copier le script
    if sudo cp "$PROJECT_DIR/sk" "$script_path"; then
        sudo chmod +x "$script_path"
        print_success "Script installÃ© avec succÃ¨s!"
        print_success "Vous pouvez maintenant utiliser 'sk' depuis n'importe oÃ¹"
        echo ""
        echo "ğŸ’¡ Conseils:"
        echo "  - Utilisez 'sk' depuis le rÃ©pertoire du projet ou ses sous-rÃ©pertoires"
        echo "  - Le script dÃ©tectera automatiquement le bon rÃ©pertoire de projet"
        echo "  - Pour dÃ©sinstaller: sudo rm /usr/local/bin/sk"
    else
        print_error "Erreur lors de l'installation (permissions sudo requises)"
        return 1
    fi
}

# Fonction pour incrÃ©menter la version et taguer automatiquement
release_auto() {
    local type="patch"
    local version_regex='^v([0-9]+)\.([0-9]+)\.([0-9]+)$'
    if [[ "$2" == "major" || "$2" == "minor" || "$2" == "patch" ]]; then
        type="$2"
    fi

    print_section "Release automatique ($type)"
    print_step "Passage sur main et pull..."
    git checkout main || { print_error "Impossible de passer sur main"; return 1; }
    git pull origin main || { print_error "Impossible de pull main"; return 1; }

    # RÃ©cupÃ©rer le dernier tag
    last_tag=$(git tag --sort=-v:refname | grep -E "$version_regex" | head -n1)
    if [[ -z "$last_tag" ]]; then
        last_tag="v0.0.0"
    fi
    if [[ $last_tag =~ $version_regex ]]; then
        major=${BASH_REMATCH[1]}
        minor=${BASH_REMATCH[2]}
        patch=${BASH_REMATCH[3]}
    else
        major=0; minor=0; patch=0
    fi

    case "$type" in
        major)
            major=$((major+1)); minor=0; patch=0;;
        minor)
            minor=$((minor+1)); patch=0;;
        patch|*)
            patch=$((patch+1));;
    esac
    new_tag="v${major}.${minor}.${patch}"

    # Mettre Ã  jour la version dans package.json (racine)
    if [ -f "$PROJECT_DIR/package.json" ]; then
        jq ".version = \"${major}.${minor}.${patch}\"" "$PROJECT_DIR/package.json" > "$PROJECT_DIR/package.json.tmp" && mv "$PROJECT_DIR/package.json.tmp" "$PROJECT_DIR/package.json"
        print_success "Version mise Ã  jour dans package.json (racine)"
    fi
    # Mettre Ã  jour la version dans backend/package.json
    if [ -f "$PROJECT_DIR/backend/package.json" ]; then
        jq ".version = \"${major}.${minor}.${patch}\"" "$PROJECT_DIR/backend/package.json" > "$PROJECT_DIR/backend/package.json.tmp" && mv "$PROJECT_DIR/backend/package.json.tmp" "$PROJECT_DIR/backend/package.json"
        print_success "Version mise Ã  jour dans backend/package.json"
    fi
    # Mettre Ã  jour la version dans frontend/package.json
    if [ -f "$PROJECT_DIR/frontend/package.json" ]; then
        jq ".version = \"${major}.${minor}.${patch}\"" "$PROJECT_DIR/frontend/package.json" > "$PROJECT_DIR/frontend/package.json.tmp" && mv "$PROJECT_DIR/frontend/package.json.tmp" "$PROJECT_DIR/frontend/package.json"
        print_success "Version mise Ã  jour dans frontend/package.json"
    fi
    git add package.json backend/package.json frontend/package.json 2>/dev/null
    git commit -m "v${major}.${minor}.${patch}" || echo "Aucun changement Ã  committer"
    git push origin main || { print_error "Impossible de push sur main"; return 1; }

    print_step "Nouveau tag: $new_tag"
    git tag "$new_tag" || { print_error "Impossible de crÃ©er le tag"; return 1; }
    git push origin "$new_tag" || { print_error "Impossible de push le tag"; return 1; }
    print_success "Release $new_tag poussÃ©e sur main !"
}

case "$1" in
    dev)
        validate_project_directory
        echo "ğŸš€ Lancement du mode dÃ©veloppement..."
        echo "Backend sur http://localhost:3001"
        echo "Frontend sur http://localhost:3000"
        echo ""
        print_step "DÃ©marrage du backend..."
        cd "$BACKEND_DIR"
        npm run dev &
        BACKEND_PID=$!
        
        print_step "DÃ©marrage du frontend..."
        cd "$FRONTEND_DIR"
        npm run dev &
        FRONTEND_PID=$!
        
        echo ""
        print_success "DÃ©veloppement dÃ©marrÃ©!"
        echo "Appuyez sur Ctrl+C pour arrÃªter les deux serveurs"
        
        # Attendre l'interruption et tuer les processus
        trap 'echo ""; print_step "ArrÃªt des serveurs..."; kill $BACKEND_PID $FRONTEND_PID 2>/dev/null; print_success "Serveurs arrÃªtÃ©s"; exit 0' INT
        wait
        ;;
    build)
        validate_project_directory
        print_section "Construction du Frontend"
        cd "$FRONTEND_DIR"
        print_step "Installation des dÃ©pendances..."
        npm i
        echo ""
        print_step "Build en cours..."
        npm run build
        echo ""
        if [ $? -eq 0 ]; then
            print_success "ğŸ‰ Frontend buildÃ© avec succÃ¨s!"
            echo ""
            echo "ğŸ“Š Informations de build:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "ğŸ“ RÃ©pertoire: $FRONTEND_DIR"
            echo "ğŸ“¦ Build situÃ© dans: .next/"
            echo "ğŸš€ PrÃªt pour le dÃ©ploiement"
            echo ""
            echo "ğŸ’¡ Prochaines Ã©tapes:"
            echo "  â€¢ DÃ©ployer sur Vercel ou autre plateforme"
            echo "  â€¢ Ou utiliser: sk deploy-full (pour dÃ©ploiement local)"
        else
            print_error "âŒ Erreur lors du build"
            echo ""
            echo "ğŸ” VÃ©rifications suggÃ©rÃ©es:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "  â€¢ VÃ©rifiez les erreurs ci-dessus"
            echo "  â€¢ Assurez-vous que toutes les dÃ©pendances sont installÃ©es"
            echo "  â€¢ VÃ©rifiez la configuration TypeScript/Next.js"
        fi
        ;;
    start)
        validate_project_directory
        print_section "DÃ©marrage du Backend Skull King"
        cd "$BACKEND_DIR"
        pm2 start ecosystem.config.cjs --env production 2>/dev/null || {
            print_warning "Processus dÃ©jÃ  en cours, tentative de redÃ©marrage..."
            pm2 restart skullking-backend
        }
        pm2 save
        sleep 2
        echo ""
        if check_app_status; then
            print_success "ğŸ‰ Backend Skull King dÃ©marrÃ© avec succÃ¨s!"
            echo ""
            echo "ğŸ“Š Informations de connexion:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "ğŸŒ Backend: http://localhost:3001"
            echo "ğŸ¥ Health: http://localhost:3001/health"
            echo ""
            echo "ğŸ’¡ Commandes utiles:"
            echo "  â€¢ sk status    - VÃ©rifier l'Ã©tat"
            echo "  â€¢ sk logs      - Voir les logs"
            echo "  â€¢ sk monitor   - Monitoring complet"
        else
            print_error "âŒ Ã‰chec du dÃ©marrage"
            echo ""
            echo "ğŸ” VÃ©rifications suggÃ©rÃ©es:"
            echo "  â€¢ VÃ©rifiez les logs: sk logs"
            echo "  â€¢ VÃ©rifiez les permissions"
            echo "  â€¢ RedÃ©marrez: sk restart"
        fi
        ;;
    stop)
        print_section "ArrÃªt du Backend Skull King"
        pm2 stop skullking-backend 2>/dev/null || print_warning "Application dÃ©jÃ  arrÃªtÃ©e"
        echo ""
        print_success "ğŸ›‘ Backend Skull King arrÃªtÃ© avec succÃ¨s"
        echo ""
        echo "ğŸ’¡ Pour redÃ©marrer:"
        echo "  â€¢ sk start     - DÃ©marrer le backend"
        echo "  â€¢ sk restart   - RedÃ©marrer directement"
        ;;
    restart)
        print_section "RedÃ©marrage du Backend Skull King"
        cd "$BACKEND_DIR"
        pm2 restart skullking-backend 2>/dev/null || {
            print_warning "Processus non trouvÃ©, dÃ©marrage..."
            pm2 start ecosystem.config.cjs --env production
        }
        pm2 save
        sleep 2
        echo ""
        if check_app_status; then
            print_success "ğŸ”„ Backend Skull King redÃ©marrÃ© avec succÃ¨s!"
            echo ""
            echo "ğŸ“Š Informations de connexion:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "ğŸŒ Backend: http://localhost:3001"
            echo "ğŸ¥ Health: http://localhost:3001/health"
            echo ""
            echo "ğŸ’¡ Commandes utiles:"
            echo "  â€¢ sk api       - Tester l'API"
            echo "  â€¢ sk logs      - Voir les logs"
            echo "  â€¢ sk monitor   - Monitoring complet"
        else
            print_error "âŒ Ã‰chec du redÃ©marrage"
            echo ""
            echo "ğŸ” VÃ©rifications suggÃ©rÃ©es:"
            echo "  â€¢ VÃ©rifiez les logs: sk logs"
            echo "  â€¢ Essayez un arrÃªt/dÃ©marrage: sk stop && sk start"
        fi
        ;;
    status)
        print_section "Statut du Backend Skull King"
        if check_app_status; then
            print_success "ğŸŸ¢ Backend Skull King en ligne"
            echo ""
            echo "ğŸ“Š Informations rapides:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "ğŸŒ Endpoint: http://localhost:3001"
            echo "âš¡ Processus PM2: Actif"
            echo ""
            echo "ğŸ’¡ Commandes utiles:"
            echo "  â€¢ sk api       - Test complet de l'API"
            echo "  â€¢ sk logs      - Voir les logs en temps rÃ©el"
            echo "  â€¢ sk monitor   - Monitoring dÃ©taillÃ©"
        else
            print_error "ğŸ”´ Backend Skull King hors ligne"
            echo ""
            echo "ğŸ” Actions suggÃ©rÃ©es:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "  â€¢ sk start     - DÃ©marrer le backend"
            echo "  â€¢ sk logs      - VÃ©rifier les erreurs"
            echo "  â€¢ sk deploy    - RedÃ©ployer si nÃ©cessaire"
        fi
        ;;
    logs)
        print_section "Logs du Backend Skull King"
        echo "ğŸ“‹ Affichage en temps rÃ©el (Ctrl+C pour arrÃªter)"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        pm2 logs skullking-backend 2>/dev/null || {
            print_error "Impossible d'accÃ©der aux logs"
            echo ""
            echo "ğŸ” VÃ©rifications:"
            echo "  â€¢ Le backend est-il dÃ©marrÃ©? sk status"
            echo "  â€¢ Essayez de redÃ©marrer: sk restart"
        }
        ;;
    monitor)
        monitor_function
        ;;
    update)
        update_function
        ;;
    deploy)
        echo "ğŸš€ DÃ©ploiement backend..."
        cd "$PROJECT_DIR"
        
        # Sauvegarde automatique avant dÃ©ploiement
        print_step "Sauvegarde automatique avant dÃ©ploiement..."
        backup_database || echo "Continuer sans sauvegarde..."
        
        # VÃ©rification et crÃ©ation du fichier .env backend
        print_step "VÃ©rification de la configuration d'environnement backend..."
        cd "$BACKEND_DIR"
        if [ ! -f ".env" ]; then
            if [ -f ".env.example" ]; then
                print_step "Copie de .env.example vers .env..."
                cp .env.example .env
                print_success "Fichier .env crÃ©Ã© Ã  partir de .env.example"
            else
                print_warning "Ni .env ni .env.example trouvÃ©s dans le backend"
            fi
        else
            print_success "Fichier .env dÃ©jÃ  prÃ©sent dans le backend"
        fi
        
        # ArrÃªt de l'application
        print_step "ArrÃªt de l'application si elle est en cours d'exÃ©cution..."
        pm2 stop skullking-backend 2>/dev/null || echo "Backend pas encore dÃ©marrÃ©"

        # Installation des dÃ©pendances backend
        print_step "Installation des dÃ©pendances backend..."
        cd "$BACKEND_DIR"
        npm i

        # GÃ©nÃ©ration du client Prisma
        print_step "GÃ©nÃ©ration du client Prisma..."
        npx prisma generate

        # Initialisation de la base de donnÃ©es
        print_step "Initialisation de la base de donnÃ©es de production..."
        NODE_ENV=production npx prisma db push

        # DÃ©marrage du backend avec PM2
        print_step "DÃ©marrage du backend avec PM2..."
        cd "$BACKEND_DIR"
        pm2 start ecosystem.config.cjs --env production

        # Sauvegarde de la configuration PM2
        print_step "Sauvegarde de la configuration PM2..."
        pm2 save

        # VÃ©rification finale
        sleep 5
        if check_app_status; then
            print_success "ğŸ‰ DÃ©ploiement backend terminÃ© avec succÃ¨s!"
            print_success "Backend accessible sur http://localhost:3001"
            print_success "Le frontend peut Ãªtre dÃ©ployÃ© sÃ©parÃ©ment"
        else
            print_error "âŒ ProblÃ¨me lors du dÃ©ploiement"
        fi
        ;;
    deploy-full)
        echo "ğŸš€ DÃ©ploiement complet (backend + frontend)..."
        cd "$PROJECT_DIR"
        
        # VÃ©rification et crÃ©ation du fichier .env backend
        print_step "VÃ©rification de la configuration d'environnement backend..."
        cd "$BACKEND_DIR"
        if [ ! -f ".env" ]; then
            if [ -f ".env.example" ]; then
                print_step "Copie de .env.example vers .env..."
                cp .env.example .env
                print_success "Fichier .env crÃ©Ã© Ã  partir de .env.example"
            else
                print_warning "Ni .env ni .env.example trouvÃ©s dans le backend"
            fi
        else
            print_success "Fichier .env dÃ©jÃ  prÃ©sent dans le backend"
        fi
        
        # VÃ©rification et crÃ©ation du fichier .env frontend
        print_step "VÃ©rification de la configuration d'environnement frontend..."
        cd "$FRONTEND_DIR"
        if [ ! -f ".env.local" ]; then
            if [ -f ".env.example" ]; then
                print_step "Copie de .env.example vers .env.local..."
                cp .env.example .env.local
                print_success "Fichier .env.local crÃ©Ã© Ã  partir de .env.example"
            else
                print_warning "Ni .env.local ni .env.example trouvÃ©s dans le frontend"
            fi
        else
            print_success "Fichier .env.local dÃ©jÃ  prÃ©sent dans le frontend"
        fi
        
        # ArrÃªt de l'application
        print_step "ArrÃªt de l'application si elle est en cours d'exÃ©cution..."
        pm2 stop skullking-backend 2>/dev/null || echo "Backend pas encore dÃ©marrÃ©"

        # Installation des dÃ©pendances backend
        print_step "Installation des dÃ©pendances backend..."
        cd "$BACKEND_DIR"
        npm i

        # GÃ©nÃ©ration du client Prisma
        print_step "GÃ©nÃ©ration du client Prisma..."
        npx prisma generate

        # Initialisation de la base de donnÃ©es
        print_step "Initialisation de la base de donnÃ©es de production..."
        NODE_ENV=production npx prisma db push

        # Installation des dÃ©pendances frontend
        print_step "Installation des dÃ©pendances frontend..."
        cd "$FRONTEND_DIR"
        npm i

        # Build du frontend
        print_step "Construction du frontend..."
        npm run build

        # DÃ©marrage du backend avec PM2
        print_step "DÃ©marrage du backend avec PM2..."
        cd "$BACKEND_DIR"
        pm2 start ecosystem.config.cjs --env production

        # Sauvegarde de la configuration PM2
        print_step "Sauvegarde de la configuration PM2..."
        pm2 save

        # VÃ©rification finale
        sleep 5
        if check_app_status; then
            print_success "ğŸ‰ DÃ©ploiement complet terminÃ© avec succÃ¨s!"
            print_success "Backend accessible sur http://localhost:3001"
            print_success "Frontend buildÃ© et prÃªt Ã  Ãªtre dÃ©ployÃ©"
        else
            print_error "âŒ ProblÃ¨me lors du dÃ©ploiement"
        fi
        ;;
    api)
        print_section "VÃ©rification de la santÃ© de l'API"
        if curl -s http://localhost:3001/health >/dev/null 2>&1; then
            response=$(curl -s http://localhost:3001/health)
            print_success "API accessible et fonctionnelle"
            echo ""
            
            # Parser et afficher les informations de maniÃ¨re jolie
            if command -v jq >/dev/null 2>&1; then
                # Si jq est disponible, parser le JSON proprement
                echo "ğŸ“Š DÃ©tails de santÃ©:"
                echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
                echo "ğŸŸ¢ Statut: $(echo "$response" | jq -r '.status // "N/A"')"
                echo "â° Timestamp: $(echo "$response" | jq -r '.timestamp // "N/A"')"
                echo "â±ï¸  Uptime: $(echo "$response" | jq -r '.uptime // "N/A"')"
                echo "ğŸ’¾ MÃ©moire utilisÃ©e: $(echo "$response" | jq -r '.memory.used // "N/A"')"
                echo "ğŸ’¾ MÃ©moire totale: $(echo "$response" | jq -r '.memory.total // "N/A"')"
                echo "ğŸŒ Environnement: $(echo "$response" | jq -r '.environment // "N/A"')"
                echo "ğŸ”’ SSL: $(echo "$response" | jq -r '.ssl // "N/A"')"
            else
                # Si jq n'est pas disponible, affichage simple mais joli
                echo "ğŸ“Š RÃ©ponse de l'API:"
                echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
                echo "$response" | sed 's/,/\n/g' | sed 's/[{}"]//g' | sed 's/:/: /g' | while read line; do
                    if [[ -n "$line" ]]; then
                        echo "  $line"
                    fi
                done
            fi
            echo ""
            print_success "ğŸ‰ L'API Skull King est en parfaite santÃ©!"
            echo "ğŸŒ Endpoint: http://localhost:3001/health"
        else
            print_error "API non accessible"
            echo ""
            echo "ğŸ” VÃ©rifications Ã  effectuer:"
            echo "  1. Le backend est-il dÃ©marrÃ©? (sk status)"
            echo "  2. Le port 3001 est-il libre?"
            echo "  3. Y a-t-il des erreurs dans les logs? (sk logs)"
        fi
        ;;
    install)
        install_script
        ;;
    backup)
        validate_project_directory
        print_section "Sauvegarde de la Base de DonnÃ©es"
        if backup_database; then
            echo ""
            echo "ğŸ’¡ Commandes utiles:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "  â€¢ sk restore <fichier>  - Restaurer une sauvegarde"
            echo "  â€¢ ls -la $BACKUP_DIR    - Voir toutes les sauvegardes"
        else
            echo ""
            echo "ğŸ” VÃ©rifications:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "  â€¢ La base de donnÃ©es existe-t-elle?"
            echo "  â€¢ Le backend a-t-il Ã©tÃ© initialisÃ©? sk deploy"
        fi
        ;;
    restore)
        validate_project_directory
        if [[ -n "$2" ]]; then
            print_section "Restauration de la Base de DonnÃ©es"
            restore_database "$2"
        else
            print_section "Sauvegardes Disponibles"
            if ls "$BACKUP_DIR"/*.db 1> /dev/null 2>&1; then
                echo "ğŸ“‹ Fichiers de sauvegarde trouvÃ©s:"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                ls -la "$BACKUP_DIR"/*.db
                echo ""
                echo "ğŸ“– Usage:"
                echo "â”€â”€â”€â”€â”€â”€â”€"
                echo "  sk restore <fichier_backup>"
                echo ""
                echo "ğŸ“ Exemple:"
                echo "  sk restore $BACKUP_DIR/db_backup_20250821_194101.db"
            else
                print_warning "Aucune sauvegarde trouvÃ©e dans $BACKUP_DIR"
                echo ""
                echo "ğŸ’¡ Pour crÃ©er une sauvegarde:"
                echo "  sk backup"
            fi
        fi
        ;;
    reset)
        # VÃ©rifier si l'option --y ou -y est prÃ©sente
        auto_confirm=false
        if [[ "$2" == "--y" ]] || [[ "$2" == "-y" ]]; then
            auto_confirm=true
        fi
        
        echo "ğŸ”„ RÃ©initialisation complÃ¨te du projet..."
        echo ""
        echo -e "${YELLOW}âš ï¸  ATTENTION: Cette action va supprimer toutes les donnÃ©es!${NC}"
        echo -e "${YELLOW}âš ï¸  Les utilisateurs, salles de jeu et parties seront perdues!${NC}"
        echo ""
        
        # Sauvegarde de sÃ©curitÃ© avant reset
        if [[ "$auto_confirm" != true ]]; then
            echo "ğŸ’¾ CrÃ©ation d'une sauvegarde de sÃ©curitÃ© avant reset..."
            backup_database || echo "Continuer sans sauvegarde..."
            echo ""
        fi
        
        if [ "$auto_confirm" = true ]; then
            echo "Mode automatique activÃ© (--y), confirmation ignorÃ©e"
            confirmation="o"
        else
            echo -n "ÃŠtes-vous sÃ»r de vouloir continuer? (O/n): "
            read -n 1 confirmation
            echo ""
        fi
        
        if [[ "$confirmation" =~ ^[Oo]$ ]] || [ -z "$confirmation" ]; then
            cd "$PROJECT_DIR" || {
                print_error "Impossible d'accÃ©der au rÃ©pertoire $PROJECT_DIR"
                exit 1
            }

            # Suppression des logs
            print_step "Suppression des logs..."
            if [ -d "$LOG_DIR" ]; then
                rm -rf "$LOG_DIR"
                mkdir -p "$LOG_DIR"
                touch "$LOG_DIR/combined.log"
                touch "$LOG_DIR/error.log"
                touch "$LOG_DIR/out.log"
                print_success "Logs supprimÃ©s et rÃ©pertoire recrÃ©Ã©"
            else
                print_warning "RÃ©pertoire de logs non trouvÃ©, crÃ©ation d'un nouveau"
                mkdir -p "$LOG_DIR"
            fi

            # Suppression de la base de donnÃ©es
            print_step "Suppression de la base de donnÃ©es..."
            db_path=$(find_database_path)
            if [[ -f "$db_path" ]]; then
                rm -f "$db_path"
                print_success "Base de donnÃ©es supprimÃ©e"
            fi

            # ArrÃªt et suppression du processus PM2
            print_step "ArrÃªt du processus PM2..."
            pm2 stop skullking-backend 2>/dev/null || echo "Processus dÃ©jÃ  arrÃªtÃ©"
            pm2 delete skullking-backend 2>/dev/null || echo "Processus non trouvÃ©"

            # RÃ©initialisation de la base de donnÃ©es
            print_step "RÃ©initialisation de la base de donnÃ©es..."
            cd "$BACKEND_DIR"
            npx prisma db push --force-reset

            # RedÃ©marrage
            print_step "RedÃ©marrage de l'application..."
            pm2 start ecosystem.config.cjs --env production
            pm2 save
            
            sleep 2
            if check_app_status; then
                print_success "Projet rÃ©initialisÃ© et prÃªt Ã  utiliser"
                print_success "Backend accessible sur http://localhost:3001"
            else
                print_error "Erreur lors de la rÃ©initialisation"
            fi
        else
            print_warning "RÃ©initialisation annulÃ©e"
        fi
        ;;
    release)
        # Usage: sk release [patch|minor|major]
        release_auto "$@"
        ;;
    *)
        echo -e "${PURPLE}ğŸ´â€â˜ ï¸ SKULL KING - Script de gestion unifiÃ©${NC}"
        echo "============================================="
        echo ""
        echo "Usage: sk [commande]"
        echo ""
        echo "Commandes disponibles:"
        echo ""
        echo "ğŸš€ Gestion de l'application:"
        echo "  start         - DÃ©marre le backend"
        echo "  stop          - ArrÃªte le backend"
        echo "  restart       - RedÃ©marre le backend"
        echo "  status        - Affiche le statut du backend"
        echo ""
        echo "ğŸ“Š Monitoring et logs:"
        echo "  logs          - Affiche les logs PM2 du backend en temps rÃ©el"
        echo "  monitor       - Monitoring complet avec ressources systÃ¨me"
        echo "  api           - VÃ©rifie la santÃ© de l'API backend"
        echo ""
        echo "ğŸ”§ DÃ©veloppement:"
        echo "  dev           - Lance le dÃ©veloppement (backend + frontend)"
        echo "  build         - Build le frontend uniquement"
        echo ""
        echo "ğŸš€ DÃ©ploiement:"
        echo "  deploy        - DÃ©ploiement backend uniquement (recommandÃ©)"
        echo "  deploy-full   - DÃ©ploiement backend + build frontend"
        echo "  update        - Mise Ã  jour du backend"
        echo ""
        echo "ğŸ’¾ Sauvegarde et restauration:"
        echo "  backup        - Sauvegarde la base de donnÃ©es"
        echo "  restore       - Restaure une sauvegarde (sk restore <fichier>)"
        echo ""
        echo "âš™ï¸ Configuration:"
        echo "  install       - Installe le script dans le PATH global"
        echo "  reset         - RÃ©initialise complÃ¨tement le projet (âš ï¸ SUPPRIME TOUTES LES DONNÃ‰ES)"
        echo "                  Options: --y ou -y pour confirmer automatiquement"
        echo "  release       - CrÃ©e une release automatique (patch|minor|major)"
        echo ""
        echo "Architecture:"
        echo "  ğŸ“ Backend : Port 3001 (API + Socket.IO)"
        echo "  ğŸ“ Frontend: Port 3000 (Next.js - dev) ou dÃ©ployÃ© sÃ©parÃ©ment"
        echo ""
        exit 1
        ;;
esac
