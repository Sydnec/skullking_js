name: ğŸ´â€â˜ ï¸ Skull King CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  # Allow manual trigger
  workflow_dispatch:

env:
  PROJECT_DIR: /home/sydnec/skullking_js
  DEPLOY_TIMEOUT: 300
  API_HEALTH_RETRIES: 6
  API_HEALTH_INTERVAL: 10

jobs:
  # Job de tests et validation
  test:
    name: ğŸ§ª Tests et validation
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        
      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: ğŸ“‹ Install backend dependencies
        run: |
          cd backend
          npm ci
          
      - name: ğŸ“‹ Install frontend dependencies
        run: |
          cd frontend
          npm ci
          
      - name: ğŸ” Lint backend
        run: |
          cd backend
          npm run lint || echo "âš ï¸ Pas de script lint configurÃ© pour le backend"
          
      - name: ğŸ” Lint frontend
        run: |
          cd frontend
          npm run lint || echo "âš ï¸ Pas de script lint configurÃ© pour le frontend"
          
      - name: ğŸ§ª Test backend
        run: |
          cd backend
          npm test || echo "âš ï¸ Pas de tests configurÃ©s pour le backend"
          
      - name: ğŸ§ª Test frontend
        run: |
          cd frontend
          npm test || echo "âš ï¸ Pas de tests configurÃ©s pour le frontend"
          
      - name: ğŸ”’ Audit backend dependencies
        run: |
          cd backend
          npm audit --audit-level=moderate
          
      - name: ğŸ”’ Audit frontend dependencies
        run: |
          cd frontend
          npm audit --audit-level=moderate
          
      - name: âœ… Validate project structure
        run: |
          echo "ğŸ” VÃ©rification de la structure du projet..."
          
          # VÃ©rifier les fichiers essentiels
          files_to_check=("sk" "backend/package.json" "frontend/package.json" "backend/server.js")
          for file in "${files_to_check[@]}"; do
            if [ -f "$file" ]; then
              echo "âœ… $file trouvÃ©"
            else
              echo "âŒ $file manquant"
              exit 1
            fi
          done
          
          # VÃ©rifier les dossiers
          dirs_to_check=("backend" "frontend" "docs")
          for dir in "${dirs_to_check[@]}"; do
            if [ -d "$dir" ]; then
              echo "âœ… Dossier $dir trouvÃ©"
            else
              echo "âŒ Dossier $dir manquant"
            fi
          done

  # Job de build et vÃ©rification
  build:
    name: ğŸ—ï¸ Build validation
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        
      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: ğŸ“‹ Install backend dependencies
        run: |
          cd backend
          npm ci
          
      - name: ğŸ“‹ Install frontend dependencies
        run: |
          cd frontend
          npm ci
          
      - name: ğŸ—ï¸ Build frontend
        run: |
          cd frontend
          npm run build
          
      - name: ğŸ” Validate backend syntax
        run: |
          cd backend
          echo "ğŸ” Validation de la syntaxe du backend..."
          node -c server.js
          
          # VÃ©rifier les autres fichiers JS
          find src -name "*.js" -type f | while read file; do
            echo "VÃ©rification: $file"
            node -c "$file" || exit 1
          done
          
      - name: ğŸ” Check Prisma schema
        run: |
          cd backend
          if [ -f "prisma/schema.prisma" ]; then
            echo "ğŸ” Validation du schÃ©ma Prisma..."
            npx prisma validate
          else
            echo "âš ï¸ Pas de schÃ©ma Prisma trouvÃ©"
          fi

  # Job de qualitÃ© de code
  code-quality:
    name: ğŸ” Code Quality Analysis
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        
      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: ğŸ“‹ Install dependencies
        run: |
          cd backend && npm ci
          cd ../frontend && npm ci
          
      - name: ğŸ”’ Security audit
        run: |
          echo "ğŸ”’ Audit de sÃ©curitÃ© des dÃ©pendances..."
          cd backend && npm audit --audit-level=moderate || true
          cd ../frontend && npm audit --audit-level=moderate || true
          
      - name: ğŸ“Š Check project structure
        run: |
          echo "ğŸ“Š VÃ©rification de la structure Skull King..."
          
          # VÃ©rifier la structure backend
          backend_files=("server.js" "package.json")
          for file in "${backend_files[@]}"; do
            if [ -f "backend/$file" ]; then
              echo "âœ… Backend: $file trouvÃ©"
            else
              echo "âŒ Backend: $file manquant"
            fi
          done
          
          # VÃ©rifier la structure frontend
          frontend_files=("package.json" "next.config.ts")
          for file in "${frontend_files[@]}"; do
            if [ -f "frontend/$file" ]; then
              echo "âœ… Frontend: $file trouvÃ©"
            else
              echo "âŒ Frontend: $file manquant"
            fi
          done
          
      - name: ğŸ“ Check for TODO/FIXME
        run: |
          echo "ğŸ“ Recherche de TODO/FIXME..."
          todos=$(grep -r "TODO\|FIXME\|XXX\|HACK" --include="*.js" --include="*.ts" --include="*.jsx" --include="*.tsx" backend/ frontend/ || true)
          
          if [ -n "$todos" ]; then
            echo "âš ï¸ TODO/FIXME trouvÃ©s:"
            echo "$todos"
          else
            echo "âœ… Aucun TODO/FIXME trouvÃ©"
          fi
          
      - name: ğŸ® Check game logic patterns
        run: |
          echo "ğŸ® VÃ©rification des patterns de jeu..."
          
          # VÃ©rifier les patterns spÃ©cifiques Ã  Skull King
          if grep -r "Socket\|socket" backend/; then
            echo "âœ… WebSocket patterns dÃ©tectÃ©s"
          fi
          
          if grep -r "game\|Game" backend/; then
            echo "âœ… Game logic patterns dÃ©tectÃ©s"
          fi
  # Job de dÃ©ploiement (seulement sur main avec self-hosted)
  deploy:
    name: ğŸš€ Deploy to production
    runs-on: self-hosted
    needs: [test, build, code-quality]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    timeout-minutes: 15

    steps:
      - name: ğŸ” Validate environment
        run: |
          echo "ğŸ” VÃ©rification de l'environnement..."
          
          # VÃ©rifier que le rÃ©pertoire du projet existe
          if [ ! -d "$PROJECT_DIR" ]; then
            echo "âŒ Le rÃ©pertoire $PROJECT_DIR n'existe pas"
            exit 1
          fi
          
          # VÃ©rifier que les outils nÃ©cessaires sont installÃ©s
          command -v git >/dev/null 2>&1 || { echo "âŒ Git n'est pas installÃ©"; exit 1; }
          command -v node >/dev/null 2>&1 || { echo "âŒ Node.js n'est pas installÃ©"; exit 1; }
          command -v npm >/dev/null 2>&1 || { echo "âŒ npm n'est pas installÃ©"; exit 1; }
          command -v pm2 >/dev/null 2>&1 || { echo "âŒ PM2 n'est pas installÃ©"; exit 1; }
          
          echo "âœ… Environnement validÃ©"

      - name: ğŸ’¾ Backup current state
        run: |
          echo "ï¿½ Sauvegarde de l'Ã©tat actuel..."
          cd $PROJECT_DIR
          
          # Sauvegarde automatique avec le script sk
          ./sk backup || echo "âš ï¸ Ã‰chec de la sauvegarde automatique"
          
          # Sauvegarder l'Ã©tat PM2 actuel
          pm2 save || echo "âš ï¸ Aucune application PM2 Ã  sauvegarder"
          
          # Sauvegarder le commit actuel
          echo "$(git rev-parse HEAD)" > /tmp/skullking_previous_commit
          echo "âœ… Ã‰tat sauvegardÃ©"

      - name: ğŸ“¥ Pull latest code
        run: |
          echo "ğŸ“¥ RÃ©cupÃ©ration du code le plus rÃ©cent..."
          cd $PROJECT_DIR
          
          # VÃ©rifier s'il y a des changements locaux non commitÃ©s
          if ! git diff-index --quiet HEAD --; then
            echo "âš ï¸ Changements locaux dÃ©tectÃ©s, ils seront conservÃ©s"
            git stash push -m "Auto-stash before deploy $(date)"
          fi
          
          # Tenter le pull
          if ! git pull origin main; then
            echo "âŒ Ã‰chec du git pull"
            exit 1
          fi
          
          echo "âœ… Code mis Ã  jour vers le commit: $(git rev-parse --short HEAD)"

      - name: ğŸ”§ Set permissions
        run: |
          echo "ğŸ”§ Configuration des permissions..."
          cd $PROJECT_DIR
          
          # Rendre le script sk exÃ©cutable
          chmod +x sk
          
          # Rendre les scripts backend exÃ©cutables
          if [ -f "backend/ssl-renewal.sh" ]; then
            chmod +x backend/ssl-renewal.sh
          fi
          
          # Rendre tous les scripts shell exÃ©cutables
          find . -name "*.sh" -type f -exec chmod +x {} \;
          
          echo "âœ… Permissions configurÃ©es"

      - name: âš™ï¸ Install SK script globally
        run: |
          echo "âš™ï¸ Installation du script sk globalement..."
          cd $PROJECT_DIR
          
          # Installer le script dans le PATH s'il n'y est pas dÃ©jÃ 
          if ! command -v sk >/dev/null 2>&1 || [ "$(sk status > /dev/null 2>&1; echo $?)" != "0" ]; then
            echo "ğŸ“¦ Installation/mise Ã  jour du script sk..."
            sudo cp sk /usr/local/bin/sk
            sudo chmod +x /usr/local/bin/sk
            echo "âœ… Script sk installÃ© globalement"
          else
            echo "âœ… Script sk dÃ©jÃ  installÃ© et fonctionnel"
          fi

      - name: ğŸš€ Deploy application
        id: deploy
        run: |
          echo "ğŸš€ DÃ©ploiement de l'application..."
          cd $PROJECT_DIR
          
          # Lancer le dÃ©ploiement avec timeout
          timeout $DEPLOY_TIMEOUT sk deploy
          
          if [ $? -eq 124 ]; then
            echo "âŒ Timeout du dÃ©ploiement aprÃ¨s ${DEPLOY_TIMEOUT}s"
            exit 1
          elif [ $? -ne 0 ]; then
            echo "âŒ Ã‰chec du dÃ©ploiement"
            exit 1
          fi
          
          echo "âœ… DÃ©ploiement terminÃ©"

      - name: ğŸ¥ Health check with retries
        run: |
          echo "ğŸ¥ VÃ©rification de la santÃ© de l'application..."
          cd $PROJECT_DIR
          
          # Attendre un peu que l'application dÃ©marre
          echo "â³ Attente du dÃ©marrage de l'application..."
          sleep 15
          
          # VÃ©rification avec plusieurs tentatives
          for i in $(seq 1 $API_HEALTH_RETRIES); do
            echo "ğŸ” Tentative $i/$API_HEALTH_RETRIES..."
            
            # VÃ©rifier le statut
            if sk status; then
              echo "âœ… Backend en ligne"
              
              # VÃ©rifier l'API
              if sk api; then
                echo "âœ… API fonctionnelle"
                echo "ğŸ‰ DÃ©ploiement rÃ©ussi!"
                exit 0
              else
                echo "âš ï¸ API non accessible, tentative $i/$API_HEALTH_RETRIES"
              fi
            else
              echo "âš ï¸ Backend non accessible, tentative $i/$API_HEALTH_RETRIES"
            fi
            
            if [ $i -lt $API_HEALTH_RETRIES ]; then
              echo "â³ Attente de ${API_HEALTH_INTERVAL}s avant nouvelle tentative..."
              sleep $API_HEALTH_INTERVAL
            fi
          done
          
          echo "âŒ L'application n'est pas accessible aprÃ¨s $API_HEALTH_RETRIES tentatives"
          exit 1

      - name: ğŸ”„ Rollback on failure
        if: failure()
        run: |
          echo "ğŸ”„ Rollback en cas d'Ã©chec..."
          cd $PROJECT_DIR
          
          if [ -f "/tmp/skullking_previous_commit" ]; then
            previous_commit=$(cat /tmp/skullking_previous_commit)
            echo "ğŸ”™ Retour au commit prÃ©cÃ©dent: $previous_commit"
            
            # Retourner au commit prÃ©cÃ©dent
            git reset --hard $previous_commit
            
            # RedÃ©ployer la version prÃ©cÃ©dente
            echo "ğŸ”„ RedÃ©ploiement de la version prÃ©cÃ©dente..."
            sk deploy || echo "âš ï¸ Ã‰chec du rollback automatique"
            
            # Nettoyer le fichier temporaire
            rm -f /tmp/skullking_previous_commit
          else
            echo "âš ï¸ Impossible de faire un rollback: commit prÃ©cÃ©dent non trouvÃ©"
          fi

      - name: ğŸ§¹ Cleanup
        if: always()
        run: |
          echo "ğŸ§¹ Nettoyage..."
          
          # Nettoyer les fichiers temporaires
          rm -f /tmp/skullking_previous_commit
          
          # Afficher les logs rÃ©cents en cas de problÃ¨me
          if [ "${{ job.status }}" != "success" ]; then
            echo "ğŸ“‹ Logs rÃ©cents PM2:"
            pm2 logs skullking-backend --lines 20 || echo "Aucun log PM2 disponible"
          fi
          
          echo "âœ… Nettoyage terminÃ©"

  # Job de notification
  notify:
    name: ğŸ“¢ Notification
    runs-on: ubuntu-latest
    needs: [test, build, code-quality, deploy]
    if: always()
    
    steps:
      - name: ğŸ“¢ Success notification
        if: needs.deploy.result == 'success'
        run: |
          echo "ğŸ‰ DÃ©ploiement Skull King rÃ©ussi!"
          echo "âœ… Tests: ${{ needs.test.result }}"
          echo "âœ… Build: ${{ needs.build.result }}"
          echo "âœ… Quality: ${{ needs.code-quality.result }}"
          echo "âœ… Deploy: ${{ needs.deploy.result }}"
          
      - name: âŒ Failure notification  
        if: needs.test.result == 'failure' || needs.build.result == 'failure' || needs.code-quality.result == 'failure' || needs.deploy.result == 'failure'
        run: |
          echo "âŒ Ã‰chec du workflow Skull King!"
          echo "ğŸ§ª Tests: ${{ needs.test.result }}"
          echo "ğŸ—ï¸ Build: ${{ needs.build.result }}"
          echo "ğŸ” Quality: ${{ needs.code-quality.result }}"
          echo "ğŸš€ Deploy: ${{ needs.deploy.result }}"
